/**
 * SEO Auto-Fix Cron (Engine Template)
 *
 * Analyzes pages for fixable SEO issues, creates GitHub issues, sends alerts.
 * Config-driven: reads URLs from siteConfig.
 *
 * Schedule: Weekly (Monday 6 AM UTC)
 */

import { NextRequest, NextResponse } from "next/server";
import { siteConfig, services } from "@/lib/config";
import { verifyCronSecret } from "@/lib/cron-auth";

const BASE_URL = siteConfig.url;

interface FixableIssue {
  type: "schema" | "image" | "meta" | "performance";
  page: string;
  description: string;
  fix?: string;
}

interface FixResult {
  issue: FixableIssue;
  fixed: boolean;
  changes?: string;
  error?: string;
}

interface AutoFixReport {
  timestamp: string;
  practiceName: string;
  issuesFound: number;
  issuesFixed: number;
  issueUrl?: string;
  fixes: FixResult[];
}

async function analyzePageForFixes(
  pagePath: string
): Promise<FixableIssue[]> {
  const issues: FixableIssue[] = [];
  const url = `${BASE_URL}${pagePath}`;

  try {
    const response = await fetch(url, {
      headers: { "User-Agent": "NuStack-SEOAutoFix/1.0" },
    });
    const html = await response.text();

    // Check for images without dimensions
    const imgMatches = html.match(/<img[^>]*>/gi) || [];
    for (const imgTag of imgMatches) {
      const hasWidth = /width\s*=/.test(imgTag) || /width:/.test(imgTag);
      const hasHeight = /height\s*=/.test(imgTag) || /height:/.test(imgTag);

      if (!hasWidth || !hasHeight) {
        const srcMatch = imgTag.match(/src\s*=\s*["']([^"']+)["']/i);
        if (srcMatch) {
          issues.push({
            type: "image",
            page: pagePath,
            description: `Image missing explicit dimensions: ${srcMatch[1].slice(0, 60)}`,
          });
        }
      }
    }

    // Check JSON-LD schemas
    const jsonLdMatches = html.match(
      /<script[^>]*type="application\/ld\+json"[^>]*>([\s\S]*?)<\/script>/gi
    );

    if (jsonLdMatches) {
      for (const match of jsonLdMatches) {
        const jsonContent = match
          .replace(/<script[^>]*>/i, "")
          .replace(/<\/script>/i, "")
          .trim();

        try {
          const parsed = JSON.parse(jsonContent);
          const items = parsed["@graph"] || [parsed];

          for (const item of Array.isArray(items) ? items : [items]) {
            if (
              item["@type"] === "LocalBusiness" ||
              item["@type"] === "MedicalBusiness" ||
              item["@type"] === "Dentist"
            ) {
              if (!item.priceRange) {
                issues.push({
                  type: "schema",
                  page: pagePath,
                  description: "LocalBusiness schema missing priceRange field",
                  fix: 'Add priceRange: "$$" to LocalBusiness schema',
                });
              }
            }
          }
        } catch {
          issues.push({
            type: "schema",
            page: pagePath,
            description: "Invalid JSON-LD syntax detected",
          });
        }
      }
    } else if (pagePath === "/") {
      issues.push({
        type: "schema",
        page: pagePath,
        description: "No JSON-LD structured data found on page",
      });
    }

    // Check for missing meta description
    const hasMetaDesc =
      /<meta[^>]*name\s*=\s*["']description["']/i.test(html);
    if (!hasMetaDesc) {
      issues.push({
        type: "meta",
        page: pagePath,
        description: "Missing meta description tag",
      });
    }

    // Check for missing canonical
    const hasCanonical = /<link[^>]*rel\s*=\s*["']canonical["']/i.test(html);
    if (!hasCanonical) {
      issues.push({
        type: "meta",
        page: pagePath,
        description: "Missing canonical link tag",
      });
    }
  } catch (error) {
    console.error(`Error analyzing ${pagePath}:`, error);
  }

  return issues;
}

async function createGitHubIssue(
  issues: FixableIssue[]
): Promise<string | null> {
  const githubToken = process.env.GITHUB_TOKEN;
  const githubRepo = process.env.GITHUB_REPO; // e.g. "owner/repo"

  if (!githubToken || !githubRepo) {
    console.log(
      "GITHUB_TOKEN or GITHUB_REPO not set - skipping GitHub issue creation"
    );
    return null;
  }

  const issueBody = `## SEO Auto-Fix Report

**Practice:** ${siteConfig.name}
**Scan Time:** ${new Date().toISOString()}
**Issues Detected:** ${issues.length}

### Issues Found

${issues
  .map(
    (i) =>
      `- **[${i.type.toUpperCase()}]** \`${i.page}\`: ${i.description}${i.fix ? `\n  - Suggested fix: ${i.fix}` : ""}`
  )
  .join("\n")}

---
*Generated by NuStack SEO Auto-Fix*
`;

  try {
    const response = await fetch(
      `https://api.github.com/repos/${githubRepo}/issues`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${githubToken}`,
          "Content-Type": "application/json",
          Accept: "application/vnd.github.v3+json",
        },
        body: JSON.stringify({
          title: `[SEO] ${issues.length} issue(s) detected - ${new Date().toLocaleDateString()}`,
          body: issueBody,
          labels: ["seo", "auto-fix"],
        }),
      }
    );

    if (!response.ok) {
      console.error("Failed to create issue:", await response.text());
      return null;
    }

    const data = await response.json();
    return data.html_url;
  } catch (error) {
    console.error("Error creating GitHub issue:", error);
    return null;
  }
}

async function sendFixNotification(report: AutoFixReport): Promise<boolean> {
  const apiKey = process.env.RESEND_API_KEY;
  const alertEmail =
    process.env.SEO_ALERT_EMAIL || "brad@nustack.com";

  if (!apiKey) {
    console.log("RESEND_API_KEY not set - skipping email");
    return false;
  }

  const hasIssues = report.issuesFound > 0;

  const htmlBody = `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
      <h1 style="color: ${hasIssues ? "#f59e0b" : "#22c55e"};">
        SEO Auto-Fix Report: ${report.practiceName}
      </h1>
      <p>
        <strong>Time:</strong> ${new Date(report.timestamp).toLocaleString()}<br>
        <strong>Issues Found:</strong> ${report.issuesFound}<br>
        <strong>Issues Fixed:</strong> ${report.issuesFixed}
      </p>

      ${report.issueUrl ? `<p><a href="${report.issueUrl}" style="color: #3b82f6;">View GitHub Issue</a></p>` : ""}

      ${
        report.fixes.length > 0
          ? `
        <h2>Fix Details</h2>
        <ul>
          ${report.fixes
            .map(
              (f) => `
            <li style="margin-bottom: 8px;">
              <strong>[${f.issue.type}]</strong> ${f.issue.page}<br>
              ${f.issue.description}<br>
              <span style="color: ${f.fixed ? "#22c55e" : "#ef4444"};">
                ${f.fixed ? "Fixed" : f.error || "Manual fix required"}
              </span>
            </li>
          `
            )
            .join("")}
        </ul>
      `
          : "<p>No issues detected.</p>"
      }

      <hr style="margin: 20px 0; border: none; border-top: 1px solid #e5e7eb;">
      <p style="color: #9ca3af; font-size: 12px;">
        NuStack Digital Ventures - SEO Monitor
      </p>
    </div>
  `;

  try {
    const domain = new URL(BASE_URL).hostname;
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        from: `SEO Monitor <monitor@${domain}>`,
        to: [alertEmail],
        subject: `[SEO] ${report.practiceName}: ${report.issuesFound} issue(s) detected`,
        html: htmlBody,
      }),
    });

    return response.ok;
  } catch (error) {
    console.error("Error sending email:", error);
    return false;
  }
}

async function runAutoFix(): Promise<AutoFixReport> {
  // Build pages to scan from sitemap + service pages
  const pagesToScan = [
    "/",
    "/about",
    "/contact",
    "/reviews",
    "/services",
    ...services.map((s) => `/services/${s.slug}`),
  ];

  const allIssues: FixableIssue[] = [];
  const fixes: FixResult[] = [];

  for (const pagePath of pagesToScan) {
    const issues = await analyzePageForFixes(pagePath);
    allIssues.push(...issues);
  }

  for (const issue of allIssues) {
    fixes.push({
      issue,
      fixed: false,
      error: "Requires manual review",
    });
  }

  let issueUrl: string | null = null;
  if (allIssues.length > 0) {
    issueUrl = await createGitHubIssue(allIssues);
  }

  return {
    timestamp: new Date().toISOString(),
    practiceName: siteConfig.name,
    issuesFound: allIssues.length,
    issuesFixed: fixes.filter((f) => f.fixed).length,
    issueUrl: issueUrl || undefined,
    fixes,
  };
}

export async function GET(request: NextRequest) {
  const auth = verifyCronSecret(request);
  if (!auth.valid) return auth.response!;

  try {
    console.log("Starting SEO auto-fix scan...");
    const report = await runAutoFix();

    console.log(`SEO auto-fix complete: ${report.issuesFound} issues found`);

    if (report.issuesFound > 0) {
      await sendFixNotification(report);
    }

    return NextResponse.json({ success: true, report });
  } catch (error) {
    console.error("SEO auto-fix failed:", error);
    return NextResponse.json(
      {
        error: "Auto-fix failed",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
